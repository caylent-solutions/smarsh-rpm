// ============================================================================
// RPM Bootstrap - Repo Package Manager for Gradle
// ============================================================================
// This script provides:
//   1. Auto-discovery and application of RPM package scripts from .packages/
//   2. rpmConfigure task: installs tooling and syncs packages from manifest repo
//   3. rpmClean task: removes synced packages and repo metadata
//
// Prerequisites: Python 3 and pipx must be available on PATH.
//
// Commit this file to your project. It rarely changes.
// Configuration lives in .rpmenv (Java properties format).
// ============================================================================

// ---------------------------------------------------------------------------
// 1. Read .rpmenv configuration
// ---------------------------------------------------------------------------
def rpmEnvFile = file('.rpmenv')
if (!rpmEnvFile.exists()) {
    throw new GradleException("RPM: .rpmenv not found. Create it from the smarsh-rpm example.")
}
def rpmEnv = new Properties()
rpmEnvFile.withInputStream { rpmEnv.load(it) }

// Allow environment variables to override .rpmenv values
def rpmProp = { String key ->
    System.getenv(key) ?: rpmEnv.getProperty(key)
}

def packagesDir = rpmProp('PACKAGES_DIR') ?: '.packages'
def repoUrl = rpmProp('REPO_URL')
def repoRev = rpmProp('REPO_REV')
def repoManifestsUrl = rpmProp('REPO_MANIFESTS_URL')
def repoManifestsRevision = rpmProp('REPO_MANIFESTS_REVISION')
def repoManifestsPath = rpmProp('REPO_MANIFESTS_PATH')
def gitbase = rpmProp('GITBASE')

// Expose rpmProp to package scripts so they can read .rpmenv values
// Usage in packages: def rpmProp = project.ext.get('_rpmProp')
project.ext.set('_rpmProp', rpmProp)

// ---------------------------------------------------------------------------
// 2. Auto-discover and apply package scripts from .packages/
// ---------------------------------------------------------------------------
def rpmPackagesDir = file(packagesDir)
if (rpmPackagesDir.exists()) {
    // Sort directories by name for deterministic application order
    // (e.g., smarsh-rpm-gradle-build before smarsh-rpm-gradle-unit-test)
    rpmPackagesDir.listFiles().findAll { it.isDirectory() }.sort { it.name }.each { pkgDir ->
        // Make package directory available to each script
        project.ext.set('_rpmCurrentPkgDir', pkgDir.absolutePath)
        // Apply all .gradle scripts in the package (sorted for deterministic order)
        fileTree(pkgDir) { include '*.gradle' }.sort().each { scriptFile ->
            apply from: scriptFile
        }
    }
}

// ---------------------------------------------------------------------------
// 3. rpmConfigure task
// ---------------------------------------------------------------------------
task rpmConfigure {
    group = 'rpm'
    description = 'Install tooling and sync RPM packages from manifest repository'

    doLast {
        // Step 1: Verify Python 3 and pipx are available
        logger.lifecycle("RPM: Checking prerequisites (Python 3, pipx)...")
        def pythonCheck = ['bash', '-c', 'command -v python3 || command -v python'].execute()
        pythonCheck.waitFor()
        if (pythonCheck.exitValue() != 0) {
            throw new GradleException(
                "RPM: python3 (or python) is not installed or not on PATH.\n" +
                "Install Python 3 before running rpmConfigure.\n" +
                "  - DevContainer: Python is provided by the devcontainer Python feature\n" +
                "  - CI/CD: Add a Python installation step before running Gradle\n" +
                "  - Local: Install Python 3 via your system package manager"
            )
        }
        def pipxCheck = ['bash', '-c', 'command -v pipx'].execute()
        pipxCheck.waitFor()
        if (pipxCheck.exitValue() != 0) {
            throw new GradleException(
                "RPM: pipx is not installed or not on PATH.\n" +
                "Install pipx before running rpmConfigure.\n" +
                "  - DevContainer: pipx is included with the devcontainer Python feature (installTools=true)\n" +
                "  - pip: python3 -m pip install --user pipx\n" +
                "  - apt: sudo apt install pipx\n" +
                "  - brew: brew install pipx\n" +
                "After installing: pipx ensurepath"
            )
        }
        logger.lifecycle("RPM: Python 3 and pipx are available")

        // Step 2: Install repo tool via pipx
        logger.lifecycle("RPM: Installing repo tool ${repoRev}...")
        exec {
            commandLine 'bash', '-c',
                "pipx install --force \"git+${repoUrl}@${repoRev}\" || " +
                "{ echo 'RPM: Failed to install repo tool via pipx'; exit 1; }"
        }

        // Step 3: repo init (clones manifest repo with ${GITBASE} placeholders intact)
        logger.lifecycle("RPM: Initializing repo from ${repoManifestsUrl}...")
        exec {
            commandLine 'bash', '-c',
                "echo n | repo --color=never init --no-repo-verify " +
                "-u \"${repoManifestsUrl}\" " +
                "-b \"${repoManifestsRevision}\" " +
                "-m \"${repoManifestsPath}\" " +
                "--repo-rev=\"${repoRev}\" " +
                "|| { echo 'RPM: repo init failed'; exit 1; }"
        }

        // Step 4: repo envsubst (resolves ${GITBASE} from environment)
        logger.lifecycle("RPM: Running repo envsubst to resolve \${GITBASE}...")
        exec {
            environment 'GITBASE', gitbase
            commandLine 'bash', '-c',
                "export GITBASE=\"${gitbase}\" && " +
                "repo envsubst || { echo 'RPM: repo envsubst failed'; exit 1; }"
        }

        // Step 5: repo sync (clones packages using resolved URLs)
        logger.lifecycle("RPM: Syncing packages...")
        exec {
            commandLine 'bash', '-c',
                "repo sync || { echo 'RPM: repo sync failed'; exit 1; }"
        }

        // Step 6: Update .gitignore
        def gitignore = file('.gitignore')
        def gitignoreText = gitignore.exists() ? gitignore.text : ''
        def updated = false
        if (!gitignoreText.contains("${packagesDir}/")) {
            gitignoreText += "\n${packagesDir}/\n"
            updated = true
        }
        if (!gitignoreText.contains('.repo/')) {
            gitignoreText += ".repo/\n"
            updated = true
        }
        if (updated) {
            gitignore.text = gitignoreText
            logger.lifecycle("RPM: Updated .gitignore with ${packagesDir}/ and .repo/")
        }

        logger.lifecycle("RPM: Configuration complete. Packages synced to ${packagesDir}/")
    }
}

// ---------------------------------------------------------------------------
// 4. rpmClean task
// ---------------------------------------------------------------------------
task rpmClean {
    group = 'rpm'
    description = 'Remove synced RPM packages and repo metadata'

    doLast {
        def pkgDir = file(packagesDir)
        def repoDir = file('.repo')
        if (pkgDir.exists()) {
            delete pkgDir
            logger.lifecycle("RPM: Removed ${packagesDir}/")
        }
        if (repoDir.exists()) {
            delete repoDir
            logger.lifecycle("RPM: Removed .repo/")
        }
        logger.lifecycle("RPM: Clean complete")
    }
}
